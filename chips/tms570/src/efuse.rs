use vcell::VolatileCell;
use esm;
use esm_ch::EsmError;

#[allow(dead_code)]
pub struct Efc {
    instruction: VolatileCell<u32>,      // 0x0  INSTRUCTION AN DUMPWORD REG.
    address: VolatileCell<u32>,          // 0x4  ADDRESS REG.
    data_upper: VolatileCell<u32>,       // 0x8  DATA UPPER REG.
    data_lower: VolatileCell<u32>,       // 0xC  DATA LOWER REG.
    system_config: VolatileCell<u32>,    // 0x10 SYSTEM CONFIG REG.
    system_status: VolatileCell<u32>,    // 0x14 SYSTEM STATUS REG.
    accumulator: VolatileCell<u32>,      // 0x18 ACCUMULATOR REG.
    boundary: VolatileCell<u32>,         // 0x1C BOUNDARY REG.
    key_flag: VolatileCell<u32>,         // 0x20 KEY FLAG REG.
    key: VolatileCell<u32>,              // 0x24 KEY REG.
    rsvd1: VolatileCell<u32>,            // 0x28 RESERVED
    pins: VolatileCell<u32>,             // 0x2C PINS REG.
    cra: VolatileCell<u32>,              // 0x30 CRA
    read: VolatileCell<u32>,             // 0x34 READ REG.
    programe: VolatileCell<u32>,         // 0x38 PROGRAMME REG.
    error: VolatileCell<u32>,            // 0x3C ERROR STATUS REG.
    single_bit: VolatileCell<u32>,       // 0x40 SINGLE BIT ERROR
    two_bit_error: VolatileCell<u32>,    // 0x44 DOUBLE BIT ERROR
    self_test_cycles: VolatileCell<u32>, // 0x48 SELF TEST CYCLES
    self_test_sign: VolatileCell<u32>,   // 0x4C SELF TEST SIGNATURE
}

const EFC_BASE_ADDR: *const Efc = 0xFFF8C000 as *const Efc;

const EFC_AUTOLOAD_ERROR_EN: u32     = 0x00040000;
const EFC_INSTRUCTION_ERROR_EN: u32  = 0x00080000;
const EFC_INSTRUCTION_INFO_EN: u32   = 0x00100000;
const EFC_SELF_TEST_ERROR_EN: u32    = 0x00200000;
const INPUT_ENABLE: u32              = 0x0000000F;
const ECC_SELF_TEST: u32             = 0x00002000;
const OUTPUT_ENABLE: u32             = 0x0003C000;
const EFC_SELF_TEST_ERROR: u32       = 0x00004000;
const EFC_SELF_TEST_DONE: u32        = 0x00008000;

// No Error
const EGC_ERROR_NONE: u32 = 0x0;
// Instruction done. Used to indicate that the eFuse self test has completed
const EFC_ERROR_INSTRUC_DONE: u32 = 0x1 << 5;
// An uncorrectable (multibit) error was detected during
// the power-on autoload sequence
const EFC_ERROR_UNCORRECTABLE: u32 = 0x5;
// At least one single bit error was detected and corrected during
// the power-on autoload sequence
const EFC_ERROR_SINGLE_BIT: u32 = 0x15;
// The signature generated by the ECC self-test logic did not
// match the goldensignature written in the EFCSTSIG register.
// The EDAC circuitry might have a fault
const EFC_ERROR_SIGNATURE: u32 = 0x18;

const PIN_AUTOLOAD: u32 = 0x1 << 10;
const PIN_INST_ERR: u32 = 0x1 << 11;
const PIN_SIGLE_BIT_ERR: u32 = 0x1 << 12;
const PIN_SELF_TEST_ERR: u32 = 0x1 << 14;

#[derive(Copy,Clone,PartialEq)]
pub enum EfcError {
    OnGoing = 0,    // No error
    StuckZero,      // Stuck at Zero error
    OneBit,         // One Bit error
    Other,          // Other error
}

impl Efc {
    pub unsafe fn new() -> &'static Efc {
        &*EFC_BASE_ADDR
    }

    pub fn self_test(&self) {
        // configure self-test cycles
        self.self_test_cycles.set(0x258);
        // configure self-test signature
        self.self_test_sign.set(0x5362F97F);
        // configure boundary register to start ECC self-test
        self.boundary.set(INPUT_ENABLE | ECC_SELF_TEST)
    }

    pub fn check(&self) -> EfcError {
        let error = self.error.get();
        match error {
            EGC_ERROR_NONE => {
                if self.stuck_zero() {
                    self.self_test();
                    return EfcError::OnGoing;
                } else {
                    return EfcError::StuckZero;
                }
            },
            EFC_ERROR_SINGLE_BIT => {
                self.self_test();
                return EfcError::OnGoing;
            }
            _ => return EfcError::Other,
        }
    }

    /// Run EFUSE Stuck at zero test
    pub fn stuck_zero(&self) -> bool {
        let mut result = false;
        let test = EFC_INSTRUCTION_INFO_EN | EFC_INSTRUCTION_ERROR_EN |
                   EFC_AUTOLOAD_ERROR_EN   | EFC_SELF_TEST_ERROR_EN;
        self.boundary.set(OUTPUT_ENABLE | test);

        let err = unsafe { esm::Esm::new() };
        // If not at least one of the above errors is stuck at 0.
        let pin = PIN_AUTOLOAD | PIN_INST_ERR | PIN_SIGLE_BIT_ERR | PIN_SELF_TEST_ERR;
        if self.pins.get() & pin == pin {
            // check if the ESM group1 channel 41 is set
            // and group3 channel 1 is set
            result = err.error_is_set(EsmError::EFuseSelfTestError) &&
                     err.error_is_set(EsmError::EfuseAutoload);
        }
        self.boundary.set(OUTPUT_ENABLE);
        err.clear_error(EsmError::EFuseSelfTestError);
        err.clear_error(EsmError::EfuseAutoload);
        // nERROR pin will become inactive once the LTC counter expires
        err.error_reset();
        result
    }

    pub unsafe fn self_test_completed(&self) -> bool {
        wait_until_zero!(self.pins.get(), EFC_SELF_TEST_DONE);

        let efc_self_test = EFC_ERROR_UNCORRECTABLE | EFC_ERROR_SINGLE_BIT |
                            EFC_ERROR_SIGNATURE;

        if self.pins.get() & EFC_SELF_TEST_ERROR == 0 &&
           self.error.get() & (efc_self_test | EFC_ERROR_INSTRUC_DONE) == 0 {
            // At least one EFC self-test error occurred
            let esm = esm::Esm::new();
            let efuse_err = esm.error_is_set(EsmError::EFuseError);
            let efuse_self_err = esm.error_is_set(EsmError::EFuseSelfTestError);
            if !efuse_err && !efuse_self_err {
                return true;
            }
        }
        false
    }
}
